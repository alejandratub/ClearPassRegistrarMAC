import { __assign, __decorate, __values } from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
var NgxCsvParser = /** @class */ (function () {
    function NgxCsvParser() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
        console.log("\n      *****************************************************\n      ***      For Custom Software/Web development      ***\n      *** Reach out to us at contact@developershive.com ***\n      ***  Support us https://patreon.com/tofiqquadri/  ***\n      ***     Visit us at https://developershive.com    ***\n      *****************************************************\n    ");
    }
    NgxCsvParser.prototype.parse = function (csvFile, config) {
        var _this = this;
        config = __assign(__assign({}, this.defaultCSVParserConfig), config);
        var ngxCSVParserObserver = new Observable(function (observer) {
            try {
                var csvRecords_1 = null;
                if (_this.isCSVFile(csvFile)) {
                    var reader_1 = new FileReader();
                    reader_1.readAsText(csvFile);
                    reader_1.onload = function () {
                        var csvData = reader_1.result;
                        var csvRecordsArray = _this.csvStringToArray(csvData.trim(), config.delimiter);
                        var headersRow = _this.getHeaderArray(csvRecordsArray);
                        csvRecords_1 = _this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords_1);
                        observer.complete();
                    };
                    reader_1.onerror = function () {
                        _this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    _this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                _this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    };
    NgxCsvParser.prototype.csvStringToArray = function (csvDataString, delimiter) {
        var regexPattern = new RegExp(("(\\" + delimiter + "|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\" + delimiter + "\"\\r\\n]*))"), "gi");
        var matchedPatternArray = regexPattern.exec(csvDataString);
        var resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            var cleanValue = matchedPatternArray[2] ?
                matchedPatternArray[2].replace(new RegExp("[\\\\\"](.)", "g"), '$1') : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    };
    NgxCsvParser.prototype.getDataRecordsArrayFromCSVFile = function (csvRecordsArray, headerLength, config) {
        var dataArr = [];
        var headersArray = csvRecordsArray[0];
        var startingRowToParseData = config.header ? 1 : 0;
        for (var i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            var data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                var csvRecord = {};
                for (var j = 0; j < data.length; j++) {
                    csvRecord[headersArray[j]] = data[j].trim();
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    };
    NgxCsvParser.prototype.isCSVFile = function (file) {
        return file.name.endsWith('.csv');
    };
    NgxCsvParser.prototype.getHeaderArray = function (csvRecordsArr) {
        var e_1, _a;
        var headers = csvRecordsArr[0];
        var headerArray = [];
        try {
            for (var headers_1 = __values(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
                var header = headers_1_1.value;
                headerArray.push(header);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (headers_1_1 && !headers_1_1.done && (_a = headers_1.return)) _a.call(headers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return headerArray;
    };
    NgxCsvParser.prototype.notCSVFileErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.unknownCSVParserErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.badCSVDataFormatErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.errorBuilder = function (type, message, code) {
        var ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    };
    NgxCsvParser.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
    NgxCsvParser = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NgxCsvParser);
    return NgxCsvParser;
}());
export { NgxCsvParser };
var CSVParserConfig = /** @class */ (function () {
    function CSVParserConfig() {
    }
    return CSVParserConfig;
}());
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jc3YtcGFyc2VyLyIsInNvdXJjZXMiOlsibGliL25neC1jc3YtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7QUFLNUU7SUFFSTtRQVdRLDJCQUFzQixHQUFHO1lBQzdCLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7U0FDakIsQ0FBQztRQWJFLE9BQU8sQ0FBQyxHQUFHLENBQUMsc1hBT2YsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQU9ELDRCQUFLLEdBQUwsVUFBTSxPQUFhLEVBQUUsTUFBdUI7UUFBNUMsaUJBMENDO1FBeENHLE1BQU0seUJBQ0MsSUFBSSxDQUFDLHNCQUFzQixHQUMzQixNQUFNLENBQ1osQ0FBQztRQUVGLElBQU0sb0JBQW9CLEdBQUcsSUFBSSxVQUFVLENBQUMsVUFBQyxRQUFrRDtZQUMzRixJQUFJO2dCQUNBLElBQUksWUFBVSxHQUFHLElBQUksQ0FBQztnQkFFdEIsSUFBSSxLQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUV6QixJQUFNLFFBQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO29CQUNoQyxRQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUUzQixRQUFNLENBQUMsTUFBTSxHQUFHO3dCQUNaLElBQU0sT0FBTyxHQUFHLFFBQU0sQ0FBQyxNQUFNLENBQUM7d0JBQzlCLElBQU0sZUFBZSxHQUFHLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBRSxPQUFrQixDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzt3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LFVBQTZCLFFBQXVCO1FBQ2hELElBQU0saUJBQWlCLEdBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLEVBQUUsMkJBQTJCLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0UsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxtQ0FBWSxHQUFaLFVBQWEsSUFBWSxFQUFFLE9BQVksRUFBRSxJQUFTO1FBQzlDLElBQU0saUJBQWlCLEdBQXNCLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUNyRSxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQzlCLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDcEMsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixPQUFPLGlCQUFpQixDQUFDO0lBQzdCLENBQUM7O0lBM0lRLFlBQVk7UUFIeEIsVUFBVSxDQUFDO1lBQ1IsVUFBVSxFQUFFLE1BQU07U0FDckIsQ0FBQztPQUNXLFlBQVksQ0E0SXhCO3VCQW5KRDtDQW1KQyxBQTVJRCxJQTRJQztTQTVJWSxZQUFZO0FBOEl6QjtJQUlJO0lBQWdCLENBQUM7SUFDckIsc0JBQUM7QUFBRCxDQUFDLEFBTEQsSUFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmd4Q1NWUGFyc2VyRXJyb3IgfSBmcm9tICcuL19tb2RlbC9uZ3gtY3N2LXBhcnNlci1lcnJvci5pbnRlcmZhY2UnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hDc3ZQYXJzZXIge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgKioqICAgICAgRm9yIEN1c3RvbSBTb2Z0d2FyZS9XZWIgZGV2ZWxvcG1lbnQgICAgICAqKipcclxuICAgICAgKioqIFJlYWNoIG91dCB0byB1cyBhdCBjb250YWN0QGRldmVsb3BlcnNoaXZlLmNvbSAqKipcclxuICAgICAgKioqICBTdXBwb3J0IHVzIGh0dHBzOi8vcGF0cmVvbi5jb20vdG9maXFxdWFkcmkvICAqKipcclxuICAgICAgKioqICAgICBWaXNpdCB1cyBhdCBodHRwczovL2RldmVsb3BlcnNoaXZlLmNvbSAgICAqKipcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIGApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGVmYXVsdENTVlBhcnNlckNvbmZpZyA9IHtcclxuICAgICAgICBoZWFkZXI6IHRydWUsXHJcbiAgICAgICAgZGVsaW1pdGVyOiAnLCdcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2UoY3N2RmlsZTogRmlsZSwgY29uZmlnOiBDU1ZQYXJzZXJDb25maWcpOiBPYnNlcnZhYmxlPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4ge1xyXG5cclxuICAgICAgICBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdENTVlBhcnNlckNvbmZpZyxcclxuICAgICAgICAgICAgLi4uY29uZmlnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbmd4Q1NWUGFyc2VyT2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEFycmF5PGFueT4gfCBOZ3hDU1ZQYXJzZXJFcnJvcj4pID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCBjc3ZSZWNvcmRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NTVkZpbGUoY3N2RmlsZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChjc3ZGaWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3N2RGF0YSA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZHNBcnJheSA9IHRoaXMuY3N2U3RyaW5nVG9BcnJheSgoY3N2RGF0YSBhcyBzdHJpbmcpLnRyaW0oKSwgY29uZmlnLmRlbGltaXRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzUm93ID0gdGhpcy5nZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3N2UmVjb3JkcyA9IHRoaXMuZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheSwgaGVhZGVyc1Jvdy5sZW5ndGgsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGNzdlJlY29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdENTVkZpbGVFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5neENTVlBhcnNlck9ic2VydmVyO1xyXG4gICAgfVxyXG5cclxuICAgIGNzdlN0cmluZ1RvQXJyYXkoY3N2RGF0YVN0cmluZzogc3RyaW5nLCBkZWxpbWl0ZXI6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IG5ldyBSZWdFeHAoKGAoXFxcXCR7ZGVsaW1pdGVyfXxcXFxccj9cXFxcbnxcXFxccnxeKSg/OlxcXCIoKD86XFxcXFxcXFwufFxcXCJcXFwifFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFteXFxcXCR7ZGVsaW1pdGVyfVxcXCJcXFxcclxcXFxuXSopKWApLFwiZ2lcIilcclxuICAgICAgICBsZXQgbWF0Y2hlZFBhdHRlcm5BcnJheSA9IHJlZ2V4UGF0dGVybi5leGVjKGNzdkRhdGFTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdENTViA9IFtbXV07XHJcbiAgICAgICAgd2hpbGUgKG1hdGNoZWRQYXR0ZXJuQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0ubGVuZ3RoICYmIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0gIT09IGRlbGltaXRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Q1NWLnB1c2goW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuVmFsdWUgPSBtYXRjaGVkUGF0dGVybkFycmF5WzJdID9cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMl0ucmVwbGFjZShuZXcgUmVnRXhwKCBcIltcXFxcXFxcXFxcXCJdKC4pXCIsIFwiZ1wiICksICckMScpIDogbWF0Y2hlZFBhdHRlcm5BcnJheVszXTtcclxuICAgICAgICAgICAgcmVzdWx0Q1NWW3Jlc3VsdENTVi5sZW5ndGggLSAxXS5wdXNoKGNsZWFuVmFsdWUpO1xyXG4gICAgICAgICAgICBtYXRjaGVkUGF0dGVybkFycmF5ID0gcmVnZXhQYXR0ZXJuLmV4ZWMoY3N2RGF0YVN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRDU1Y7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheTogYW55LCBoZWFkZXJMZW5ndGg6IGFueSwgY29uZmlnOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBkYXRhQXJyID0gW107XHJcbiAgICAgICAgY29uc3QgaGVhZGVyc0FycmF5ID0gY3N2UmVjb3Jkc0FycmF5WzBdO1xyXG5cclxuICAgICAgICBjb25zdCBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhID0gY29uZmlnLmhlYWRlciA/IDEgOiAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRpbmdSb3dUb1BhcnNlRGF0YTsgaSA8IGNzdlJlY29yZHNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY3N2UmVjb3Jkc0FycmF5W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSBoZWFkZXJMZW5ndGggJiYgY29uZmlnLmhlYWRlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZFtoZWFkZXJzQXJyYXlbal1dID0gZGF0YVtqXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRhQXJyLnB1c2goY3N2UmVjb3JkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGFBcnIucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YUFycjtcclxuICAgIH1cclxuXHJcbiAgICBpc0NTVkZpbGUoZmlsZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGUubmFtZS5lbmRzV2l0aCgnLmNzdicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnI6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjc3ZSZWNvcmRzQXJyWzBdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xyXG4gICAgICAgICAgICBoZWFkZXJBcnJheS5wdXNoKGhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID1cclxuICAgICAgICAgICAgdGhpcy5lcnJvckJ1aWxkZXIoJ05PVF9BX0NTVl9GSUxFJywgJ1NlbGVjdGVkIGZpbGUgaXMgbm90IGEgY3N2IEZpbGUgVHlwZS4nLCAyKTtcclxuICAgICAgICBvYnNlcnZlci5lcnJvcihuZ2NDU1ZQYXJzZXJFcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCdWlsZGVyKCdVTktOT1dOX0VSUk9SJywgJ1Vua25vd24gZXJyb3IuIFBsZWFzZSByZWZlciB0byBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGZvciBsaWJyYXJ5IHVzYWdlLicsIDQwNCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPVxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQnVpbGRlcignQkFEX0NTVl9EQVRBX0ZPUk1BVCcsICdVbmFibGUgdG8gcGFyc2UgQ1NWIEZpbGUuJywgMSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGVycm9yQnVpbGRlcih0eXBlOiBzdHJpbmcsIG1lc3NhZ2U6IGFueSwgY29kZTogYW55KTogTmd4Q1NWUGFyc2VyRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHJldHVybiBuZ2NDU1ZQYXJzZXJFcnJvcjtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQ1NWUGFyc2VyQ29uZmlnIHtcclxuICAgIGhlYWRlcj86IGJvb2xlYW47XHJcbiAgICBkZWxpbWl0ZXI/OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxufVxyXG4iXX0=